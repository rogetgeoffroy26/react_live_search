(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global = global || self, global.Searchbase = factory());
}(this, (function () { 'use strict';

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _extends() {
    _extends = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    return _extends.apply(this, arguments);
  }

  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function createCommonjsModule(fn, module) {
  	return module = { exports: {} }, fn(module, module.exports), module.exports;
  }

  var browserPonyfill = createCommonjsModule(function (module, exports) {
    var __self__ = function (root) {
      function F() {
        this.fetch = false;
        this.DOMException = root.DOMException;
      }

      F.prototype = root;
      return new F();
    }(typeof self !== 'undefined' ? self : commonjsGlobal);

    (function (self) {
      var irrelevant = function (exports) {
        var support = {
          searchParams: 'URLSearchParams' in self,
          iterable: 'Symbol' in self && 'iterator' in Symbol,
          blob: 'FileReader' in self && 'Blob' in self && function () {
            try {
              new Blob();
              return true;
            } catch (e) {
              return false;
            }
          }(),
          formData: 'FormData' in self,
          arrayBuffer: 'ArrayBuffer' in self
        };

        function isDataView(obj) {
          return obj && DataView.prototype.isPrototypeOf(obj);
        }

        if (support.arrayBuffer) {
          var viewClasses = ['[object Int8Array]', '[object Uint8Array]', '[object Uint8ClampedArray]', '[object Int16Array]', '[object Uint16Array]', '[object Int32Array]', '[object Uint32Array]', '[object Float32Array]', '[object Float64Array]'];

          var isArrayBufferView = ArrayBuffer.isView || function (obj) {
            return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
          };
        }

        function normalizeName(name) {
          if (typeof name !== 'string') {
            name = String(name);
          }

          if (/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(name)) {
            throw new TypeError('Invalid character in header field name');
          }

          return name.toLowerCase();
        }

        function normalizeValue(value) {
          if (typeof value !== 'string') {
            value = String(value);
          }

          return value;
        } // Build a destructive iterator for the value list


        function iteratorFor(items) {
          var iterator = {
            next: function next() {
              var value = items.shift();
              return {
                done: value === undefined,
                value: value
              };
            }
          };

          if (support.iterable) {
            iterator[Symbol.iterator] = function () {
              return iterator;
            };
          }

          return iterator;
        }

        function Headers(headers) {
          this.map = {};

          if (headers instanceof Headers) {
            headers.forEach(function (value, name) {
              this.append(name, value);
            }, this);
          } else if (Array.isArray(headers)) {
            headers.forEach(function (header) {
              this.append(header[0], header[1]);
            }, this);
          } else if (headers) {
            Object.getOwnPropertyNames(headers).forEach(function (name) {
              this.append(name, headers[name]);
            }, this);
          }
        }

        Headers.prototype.append = function (name, value) {
          name = normalizeName(name);
          value = normalizeValue(value);
          var oldValue = this.map[name];
          this.map[name] = oldValue ? oldValue + ', ' + value : value;
        };

        Headers.prototype['delete'] = function (name) {
          delete this.map[normalizeName(name)];
        };

        Headers.prototype.get = function (name) {
          name = normalizeName(name);
          return this.has(name) ? this.map[name] : null;
        };

        Headers.prototype.has = function (name) {
          return this.map.hasOwnProperty(normalizeName(name));
        };

        Headers.prototype.set = function (name, value) {
          this.map[normalizeName(name)] = normalizeValue(value);
        };

        Headers.prototype.forEach = function (callback, thisArg) {
          for (var name in this.map) {
            if (this.map.hasOwnProperty(name)) {
              callback.call(thisArg, this.map[name], name, this);
            }
          }
        };

        Headers.prototype.keys = function () {
          var items = [];
          this.forEach(function (value, name) {
            items.push(name);
          });
          return iteratorFor(items);
        };

        Headers.prototype.values = function () {
          var items = [];
          this.forEach(function (value) {
            items.push(value);
          });
          return iteratorFor(items);
        };

        Headers.prototype.entries = function () {
          var items = [];
          this.forEach(function (value, name) {
            items.push([name, value]);
          });
          return iteratorFor(items);
        };

        if (support.iterable) {
          Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
        }

        function consumed(body) {
          if (body.bodyUsed) {
            return Promise.reject(new TypeError('Already read'));
          }

          body.bodyUsed = true;
        }

        function fileReaderReady(reader) {
          return new Promise(function (resolve, reject) {
            reader.onload = function () {
              resolve(reader.result);
            };

            reader.onerror = function () {
              reject(reader.error);
            };
          });
        }

        function readBlobAsArrayBuffer(blob) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          reader.readAsArrayBuffer(blob);
          return promise;
        }

        function readBlobAsText(blob) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          reader.readAsText(blob);
          return promise;
        }

        function readArrayBufferAsText(buf) {
          var view = new Uint8Array(buf);
          var chars = new Array(view.length);

          for (var i = 0; i < view.length; i++) {
            chars[i] = String.fromCharCode(view[i]);
          }

          return chars.join('');
        }

        function bufferClone(buf) {
          if (buf.slice) {
            return buf.slice(0);
          } else {
            var view = new Uint8Array(buf.byteLength);
            view.set(new Uint8Array(buf));
            return view.buffer;
          }
        }

        function Body() {
          this.bodyUsed = false;

          this._initBody = function (body) {
            this._bodyInit = body;

            if (!body) {
              this._bodyText = '';
            } else if (typeof body === 'string') {
              this._bodyText = body;
            } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
              this._bodyBlob = body;
            } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
              this._bodyFormData = body;
            } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
              this._bodyText = body.toString();
            } else if (support.arrayBuffer && support.blob && isDataView(body)) {
              this._bodyArrayBuffer = bufferClone(body.buffer); // IE 10-11 can't handle a DataView body.

              this._bodyInit = new Blob([this._bodyArrayBuffer]);
            } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
              this._bodyArrayBuffer = bufferClone(body);
            } else {
              this._bodyText = body = Object.prototype.toString.call(body);
            }

            if (!this.headers.get('content-type')) {
              if (typeof body === 'string') {
                this.headers.set('content-type', 'text/plain;charset=UTF-8');
              } else if (this._bodyBlob && this._bodyBlob.type) {
                this.headers.set('content-type', this._bodyBlob.type);
              } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
              }
            }
          };

          if (support.blob) {
            this.blob = function () {
              var rejected = consumed(this);

              if (rejected) {
                return rejected;
              }

              if (this._bodyBlob) {
                return Promise.resolve(this._bodyBlob);
              } else if (this._bodyArrayBuffer) {
                return Promise.resolve(new Blob([this._bodyArrayBuffer]));
              } else if (this._bodyFormData) {
                throw new Error('could not read FormData body as blob');
              } else {
                return Promise.resolve(new Blob([this._bodyText]));
              }
            };

            this.arrayBuffer = function () {
              if (this._bodyArrayBuffer) {
                return consumed(this) || Promise.resolve(this._bodyArrayBuffer);
              } else {
                return this.blob().then(readBlobAsArrayBuffer);
              }
            };
          }

          this.text = function () {
            var rejected = consumed(this);

            if (rejected) {
              return rejected;
            }

            if (this._bodyBlob) {
              return readBlobAsText(this._bodyBlob);
            } else if (this._bodyArrayBuffer) {
              return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
            } else if (this._bodyFormData) {
              throw new Error('could not read FormData body as text');
            } else {
              return Promise.resolve(this._bodyText);
            }
          };

          if (support.formData) {
            this.formData = function () {
              return this.text().then(decode);
            };
          }

          this.json = function () {
            return this.text().then(JSON.parse);
          };

          return this;
        } // HTTP methods whose capitalization should be normalized


        var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];

        function normalizeMethod(method) {
          var upcased = method.toUpperCase();
          return methods.indexOf(upcased) > -1 ? upcased : method;
        }

        function Request(input, options) {
          options = options || {};
          var body = options.body;

          if (input instanceof Request) {
            if (input.bodyUsed) {
              throw new TypeError('Already read');
            }

            this.url = input.url;
            this.credentials = input.credentials;

            if (!options.headers) {
              this.headers = new Headers(input.headers);
            }

            this.method = input.method;
            this.mode = input.mode;
            this.signal = input.signal;

            if (!body && input._bodyInit != null) {
              body = input._bodyInit;
              input.bodyUsed = true;
            }
          } else {
            this.url = String(input);
          }

          this.credentials = options.credentials || this.credentials || 'same-origin';

          if (options.headers || !this.headers) {
            this.headers = new Headers(options.headers);
          }

          this.method = normalizeMethod(options.method || this.method || 'GET');
          this.mode = options.mode || this.mode || null;
          this.signal = options.signal || this.signal;
          this.referrer = null;

          if ((this.method === 'GET' || this.method === 'HEAD') && body) {
            throw new TypeError('Body not allowed for GET or HEAD requests');
          }

          this._initBody(body);
        }

        Request.prototype.clone = function () {
          return new Request(this, {
            body: this._bodyInit
          });
        };

        function decode(body) {
          var form = new FormData();
          body.trim().split('&').forEach(function (bytes) {
            if (bytes) {
              var split = bytes.split('=');
              var name = split.shift().replace(/\+/g, ' ');
              var value = split.join('=').replace(/\+/g, ' ');
              form.append(decodeURIComponent(name), decodeURIComponent(value));
            }
          });
          return form;
        }

        function parseHeaders(rawHeaders) {
          var headers = new Headers(); // Replace instances of \r\n and \n followed by at least one space or horizontal tab with a space
          // https://tools.ietf.org/html/rfc7230#section-3.2

          var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, ' ');
          preProcessedHeaders.split(/\r?\n/).forEach(function (line) {
            var parts = line.split(':');
            var key = parts.shift().trim();

            if (key) {
              var value = parts.join(':').trim();
              headers.append(key, value);
            }
          });
          return headers;
        }

        Body.call(Request.prototype);

        function Response(bodyInit, options) {
          if (!options) {
            options = {};
          }

          this.type = 'default';
          this.status = options.status === undefined ? 200 : options.status;
          this.ok = this.status >= 200 && this.status < 300;
          this.statusText = 'statusText' in options ? options.statusText : 'OK';
          this.headers = new Headers(options.headers);
          this.url = options.url || '';

          this._initBody(bodyInit);
        }

        Body.call(Response.prototype);

        Response.prototype.clone = function () {
          return new Response(this._bodyInit, {
            status: this.status,
            statusText: this.statusText,
            headers: new Headers(this.headers),
            url: this.url
          });
        };

        Response.error = function () {
          var response = new Response(null, {
            status: 0,
            statusText: ''
          });
          response.type = 'error';
          return response;
        };

        var redirectStatuses = [301, 302, 303, 307, 308];

        Response.redirect = function (url, status) {
          if (redirectStatuses.indexOf(status) === -1) {
            throw new RangeError('Invalid status code');
          }

          return new Response(null, {
            status: status,
            headers: {
              location: url
            }
          });
        };

        exports.DOMException = self.DOMException;

        try {
          new exports.DOMException();
        } catch (err) {
          exports.DOMException = function (message, name) {
            this.message = message;
            this.name = name;
            var error = Error(message);
            this.stack = error.stack;
          };

          exports.DOMException.prototype = Object.create(Error.prototype);
          exports.DOMException.prototype.constructor = exports.DOMException;
        }

        function fetch(input, init) {
          return new Promise(function (resolve, reject) {
            var request = new Request(input, init);

            if (request.signal && request.signal.aborted) {
              return reject(new exports.DOMException('Aborted', 'AbortError'));
            }

            var xhr = new XMLHttpRequest();

            function abortXhr() {
              xhr.abort();
            }

            xhr.onload = function () {
              var options = {
                status: xhr.status,
                statusText: xhr.statusText,
                headers: parseHeaders(xhr.getAllResponseHeaders() || '')
              };
              options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');
              var body = 'response' in xhr ? xhr.response : xhr.responseText;
              resolve(new Response(body, options));
            };

            xhr.onerror = function () {
              reject(new TypeError('Network request failed'));
            };

            xhr.ontimeout = function () {
              reject(new TypeError('Network request failed'));
            };

            xhr.onabort = function () {
              reject(new exports.DOMException('Aborted', 'AbortError'));
            };

            xhr.open(request.method, request.url, true);

            if (request.credentials === 'include') {
              xhr.withCredentials = true;
            } else if (request.credentials === 'omit') {
              xhr.withCredentials = false;
            }

            if ('responseType' in xhr && support.blob) {
              xhr.responseType = 'blob';
            }

            request.headers.forEach(function (value, name) {
              xhr.setRequestHeader(name, value);
            });

            if (request.signal) {
              request.signal.addEventListener('abort', abortXhr);

              xhr.onreadystatechange = function () {
                // DONE (success or failure)
                if (xhr.readyState === 4) {
                  request.signal.removeEventListener('abort', abortXhr);
                }
              };
            }

            xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);
          });
        }

        fetch.polyfill = true;

        if (!self.fetch) {
          self.fetch = fetch;
          self.Headers = Headers;
          self.Request = Request;
          self.Response = Response;
        }

        exports.Headers = Headers;
        exports.Request = Request;
        exports.Response = Response;
        exports.fetch = fetch;
        return exports;
      }({});
    })(__self__);

    delete __self__.fetch.polyfill;
    exports = __self__.fetch; // To enable: import fetch from 'cross-fetch'

    exports["default"] = __self__.fetch; // For TypeScript consumers without esModuleInterop.

    exports.fetch = __self__.fetch; // To enable: import {fetch} from 'cross-fetch'

    exports.Headers = __self__.Headers;
    exports.Request = __self__.Request;
    exports.Response = __self__.Response;
    module.exports = exports;
  });
  var browserPonyfill_1 = browserPonyfill.fetch;
  var browserPonyfill_2 = browserPonyfill.Headers;
  var browserPonyfill_3 = browserPonyfill.Request;
  var browserPonyfill_4 = browserPonyfill.Response;

  function _extends$1() {
    _extends$1 = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    return _extends$1.apply(this, arguments);
  }

  // Function to parse the URL
  function btoa$1(input) {
    if (input === void 0) {
      input = '';
    }

    var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
    var str = input;
    var output = ''; // eslint-disable-next-line

    for (var block = 0, charCode, i = 0, map = chars; str.charAt(i | 0) || (map = '=', i % 1); // eslint-disable-line no-bitwise
    output += map.charAt(63 & block >> 8 - i % 1 * 8) // eslint-disable-line no-bitwise
    ) {
      charCode = str.charCodeAt(i += 3 / 4);

      if (charCode > 0xff) {
        throw new Error('"btoa" failed: The string to be encoded contains characters outside of the Latin1 range.');
      }

      block = block << 8 | charCode; // eslint-disable-line no-bitwise
    }

    return output;
  }

  function validateIndex(index) {
    if (!index) {
      throw new Error('appbase-analytics: A valid index must be present to record analytics events.');
    }
  }
  function validateCredentials(credentials) {
    if (!credentials) {
      throw new Error('appbase-analytics: Auth credentials is missing.');
    }
  }
  function validateURL(url) {
    if (!url) {
      throw new Error('appbase-analytics: URL is missing.');
    }
  }
  function validateQuery(query, queryID) {
    if ((query === undefined || query === null) && !queryID) {
      throw new Error('appbase-analytics: query or queryID must be present to register a click/conversion event');
    }
  }
  function validateClickObjects(objects) {
    if (!objects || Object.keys(objects).length < 1) {
      throw new Error('appbase-analytics: at least one click object must be present to register a click event');
    }
  }
  function validateConversionObjects(objects) {
    if (!objects || Object.keys(objects).length < 1) {
      throw new Error('appbase-analytics: at least one click object must be present to register a click event');
    }
  }

  function initClient(config) {
    if (config === void 0) {
      config = {};
    }

    var metrics = {
      credentials: config.credentials,
      index: config.index,
      url: config.url,
      userID: config.userID,
      globalEventData: config.globalEventData,
      queryID: '',
      headers: null
    };
    validateIndex(metrics.index);
    validateCredentials(metrics.credentials);
    validateURL(metrics.url);

    metrics._request = function (url, body, callback) {
      var finalBody = _extends$1({}, body, {
        user_id: metrics.userID,
        event_data: _extends$1({}, body && body.event_data, {}, metrics.globalEventData)
      });

      return browserPonyfill(metrics.url + "/" + metrics.index + "/_analytics/" + url, {
        method: 'PUT',
        headers: _extends$1({}, metrics.headers, {
          'Content-Type': 'application/json',
          Authorization: "Basic " + btoa$1(metrics.credentials)
        }),
        body: JSON.stringify(finalBody)
      }).then(function (response) {
        if (callback) {
          callback(null, response);
        }
      })["catch"](function (err) {
        console.error(err);

        if (callback) {
          callback(err, null);
        }
      });
    }; // To register a search


    metrics.search = function (searchConfig, callback) {
      validateQuery(searchConfig.query, searchConfig.queryID);

      var captureQueryID = function captureQueryID(err, res) {
        if (res) {
          res.json().then(function (response) {
            if (response && response.query_id) {
              metrics.queryID = response.query_id;
            }
          })["catch"](function (error) {
            console.error(error);
          });
        }

        if (callback) {
          callback(err, res);
        }
      }; // just to avoid the flow type error


      if (metrics._request) {
        var requestBody = {
          query: searchConfig.query,
          query_id: searchConfig.queryID,
          event_data: searchConfig.eventData,
          filters: searchConfig.filters,
          hits: searchConfig.hits
        };

        metrics._request('search', requestBody, captureQueryID);
      }
    }; // To register a click


    metrics.click = function (clickConfig, callback) {
      validateQuery(clickConfig.query, clickConfig.queryID);
      validateClickObjects(clickConfig.objects); // just to avoid the flow type error

      if (metrics._request) {
        var requestBody = {
          click_on: clickConfig.objects,
          click_type: clickConfig.isSuggestionClick ? 'suggestion' : 'result',
          query: clickConfig.query,
          query_id: clickConfig.queryID,
          event_data: clickConfig.eventData
        };

        metrics._request('click', requestBody, callback);
      }
    }; // To register a conversion


    metrics.conversion = function (conversionConfig, callback) {
      validateQuery(conversionConfig.query, conversionConfig.queryID);
      validateConversionObjects(conversionConfig.objects); // just to avoid the flow type error

      if (metrics._request) {
        var requestBody = {
          conversion_on: conversionConfig.objects,
          query: conversionConfig.query,
          query_id: conversionConfig.queryID,
          event_data: conversionConfig.eventData
        };

        metrics._request('conversion', requestBody, callback);
      }
    }; // Sets the userID


    metrics.setUserID = function (userID) {
      metrics.userID = userID;
    }; // Sets the global events


    metrics.setGlobalEventData = function (globalEvents) {
      metrics.globalEventData = globalEvents;
    }; // Sets the headers


    metrics.setHeaders = function (headers) {
      metrics.headers = headers;
    };

    return metrics;
  }

  var index = {
    init: initClient
  };

  var highlightResults = function highlightResults(result) {
    var data = _extends({}, result);

    if (data.highlight) {
      Object.keys(data.highlight).forEach(function (highlightItem) {
        var _extends2;

        var highlightValue = data.highlight[highlightItem][0];
        data._source = _extends({}, data._source, (_extends2 = {}, _extends2[highlightItem] = highlightValue, _extends2));
      });
    }

    return data;
  };
  var parseHits = function parseHits(hits) {
    var results = [];

    if (hits) {
      results = [].concat(hits).map(function (item) {
        var streamProps = {};

        if (item._updated) {
          streamProps._updated = item._updated;
        } else if (item._deleted) {
          streamProps._deleted = item._deleted;
        }

        var data = highlightResults(item);
        var result = Object.keys(data).filter(function (key) {
          return key !== '_source';
        }).reduce(function (obj, key) {
          // eslint-disable-next-line
          obj[key] = data[key];
          return obj;
        }, _extends({}, data._source, {}, streamProps));
        return result;
      });
    }

    return results;
  }; // flattens a nested array

  var flatten = function flatten(arr) {
    return arr.reduce(function (flat, toFlatten) {
      return flat.concat(Array.isArray(toFlatten) ? flatten(toFlatten) : toFlatten);
    }, []);
  }; // helper function to extract suggestions

  var extractSuggestion = function extractSuggestion(val) {
    if (typeof val === 'object') {
      if (Array.isArray(val)) {
        return flatten(val);
      }

      return null;
    }

    return val;
  };
  var getSuggestions = function getSuggestions(fields, suggestions, currentValue) {
    if (fields === void 0) {
      fields = [];
    }

    if (currentValue === void 0) {
      currentValue = '';
    }

    var suggestionsList = [];
    var labelsList = [];

    var populateSuggestionsList = function populateSuggestionsList(val, parsedSource, source) {
      // check if the suggestion includes the current value
      // and not already included in other suggestions
      var isWordMatch = currentValue.trim().split(' ').some(function (term) {
        return String(val).toLowerCase().includes(term);
      });

      if (isWordMatch && !labelsList.includes(val) || source._promoted) {
        var defaultOption = {
          label: val,
          value: val,
          source: source
        };
        labelsList = [].concat(labelsList, [val]);
        suggestionsList = [].concat(suggestionsList, [defaultOption]);
      }
    };

    var parseField = function parseField(parsedSource, field, source) {
      if (field === void 0) {
        field = '';
      }

      if (source === void 0) {
        source = parsedSource;
      }

      if (typeof parsedSource === 'object') {
        var fieldNodes = field.split('.');
        var label = parsedSource[fieldNodes[0]];

        if (label) {
          if (fieldNodes.length > 1) {
            // nested fields of the 'foo.bar.zoo' variety
            var children = field.substring(fieldNodes[0].length + 1);

            if (Array.isArray(label)) {
              label.forEach(function (arrayItem) {
                parseField(arrayItem, children, source);
              });
            } else {
              parseField(label, children, source);
            }
          } else {
            var val = extractSuggestion(label);

            if (val) {
              if (Array.isArray(val)) {
                val.forEach(function (suggestion) {
                  return populateSuggestionsList(suggestion, parsedSource, source);
                });
              } else {
                populateSuggestionsList(val, parsedSource, source);
              }
            }
          }
        }
      }
    };

    suggestions.forEach(function (item) {
      var _score = item._score,
          _index = item._index,
          _type = item._type,
          _id = item._id;

      var source = _extends({}, item, {
        _id: _id,
        _index: _index,
        _score: _score,
        _type: _type
      });

      fields.forEach(function (field) {
        parseField(source, field);
      });
    });
    return suggestionsList;
  };
  function parseCompAggToHits(aggFieldName, buckets) {
    if (buckets === void 0) {
      buckets = [];
    }

    return buckets.map(function (bucket) {
      // eslint-disable-next-line camelcase
      var doc_count = bucket.doc_count,
          key = bucket.key,
          hitsData = bucket[aggFieldName];
      return _extends({
        _doc_count: doc_count,
        _key: key[aggFieldName]
      }, hitsData.hits.hits[0]);
    });
  }

  var Results =
  /*#__PURE__*/
  function () {
    // An array of results obtained from the applied query.
    // Raw response returned by ES query
    // Results parser
    function Results(data) {
      var _this = this;

      _defineProperty(this, "data", void 0);

      _defineProperty(this, "raw", void 0);

      _defineProperty(this, "parseResults", void 0);

      _defineProperty(this, "setRaw", function (rawResponse) {
        // set response
        _this.raw = rawResponse;

        if (rawResponse.hits && rawResponse.hits.hits) {
          _this.setData(rawResponse.hits.hits);
        }
      });

      this.data = data || [];
    } // Total number of results found


    var _proto = Results.prototype;

    // Method to set data explicitly
    _proto.setData = function setData(data) {
      // parse hits
      var filteredResults = parseHits(data); // filter results & remove duplicates if any

      if (this.promotedData.length) {
        var ids = this.promotedData.map(function (item) {
          return item._id;
        }).filter(Boolean);

        if (ids) {
          filteredResults = filteredResults.filter(function (item) {
            return !ids.includes(item._id);
          });
        }

        filteredResults = [].concat(this.promotedData.map(function (dataItem) {
          return _extends({}, dataItem, {
            _promoted: true
          });
        }), filteredResults);
      } // set data


      if (this.parseResults) {
        this.data = this.parseResults(filteredResults, data);
      } else {
        this.data = filteredResults;
      }
    };

    _createClass(Results, [{
      key: "numberOfResults",
      get: function get() {
        // calculate from raw response
        if (this.raw && this.raw.hits) {
          return typeof this.raw.hits.total === 'object' ? this.raw.hits.total.value : this.raw.hits.total;
        }

        return 0;
      } // Total time taken by request (in ms)

    }, {
      key: "time",
      get: function get() {
        // calculate from raw response
        if (this.raw) {
          return this.raw.took;
        }

        return 0;
      } // no of hidden results found

    }, {
      key: "hidden",
      get: function get() {
        if (this.raw && this.raw.hits) {
          return this.raw.hits.hidden || 0;
        }

        return 0;
      } // no of promoted results found

    }, {
      key: "promoted",
      get: function get() {
        if (this.raw && this.raw.promoted) {
          return this.raw.promoted.length;
        }

        return 0;
      } // An array of promoted results obtained from the applied query.

    }, {
      key: "promotedData",
      get: function get() {
        if (this.raw && this.raw.promoted) {
          return this.raw.promoted || [];
        }

        return [];
      } // An object of raw response as-is from elasticsearch query

    }, {
      key: "rawData",
      get: function get() {
        return this.raw || {};
      } // object of custom data applied through queryRules
      // only works when `enableAppbase=true`

    }, {
      key: "customData",
      get: function get() {
        if (this.raw && this.raw.customData) {
          return this.raw.customData || {};
        }

        return {};
      }
    }]);

    return Results;
  }();

  var Observable =
  /*#__PURE__*/
  function () {
    function Observable() {
      _defineProperty(this, "observers", void 0);

      this.observers = [];
    }

    var _proto = Observable.prototype;

    _proto.subscribe = function subscribe(fn, propertiesToSubscribe) {
      this.observers.push({
        callback: fn,
        properties: propertiesToSubscribe
      });
    };

    _proto.unsubscribe = function unsubscribe(fn) {
      if (fn) {
        this.observers = this.observers.filter(function (item) {
          if (item.callback !== fn) {
            return item;
          }

          return null;
        });
      } else {
        this.observers = [];
      }
    };

    _proto.next = function next(o, property, thisObj) {
      var scope = thisObj || window;
      this.observers.forEach(function (item) {
        // filter by subscribed properties
        if (item.properties === undefined) {
          item.callback.call(scope, o);
        } else if (item.properties instanceof Array && item.properties.length && item.properties.includes(property)) {
          item.callback.call(scope, o);
        } else if (typeof item.properties === 'string' && item.properties && item.properties === property) {
          item.callback.call(scope, o);
        }
      });
    };

    return Observable;
  }();

  var CompositeAggregationResults =
  /*#__PURE__*/
  function () {
    // An array of composite aggregations obtained from the applied aggs in options.
    // useful when loading data of greater size
    // Raw aggregations returned by ES query
    function CompositeAggregationResults(data) {
      _defineProperty(this, "data", void 0);

      _defineProperty(this, "afterKey", void 0);

      _defineProperty(this, "raw", void 0);

      this.data = data || [];
    } // An object of raw response as-is from elasticsearch query


    var _proto = CompositeAggregationResults.prototype;

    _proto.setRaw = function setRaw(rawResponse) {
      // set response
      this.raw = rawResponse;
      if (rawResponse.after_key) this.setAfterKey(rawResponse.after_key);
    };

    _proto.setAfterKey = function setAfterKey(key) {
      this.afterKey = key;
    } // Method to set data explicitly
    ;

    _proto.setData = function setData(aggField, data) {
      // parse aggregation buckets
      this.data = parseCompAggToHits(aggField, data);
    };

    _createClass(CompositeAggregationResults, [{
      key: "rawData",
      get: function get() {
        return this.raw || {};
      }
    }]);

    return CompositeAggregationResults;
  }();

  var MIC_STATUS = {
    inactive: 'INACTIVE',
    active: 'ACTIVE',
    denied: 'DENIED'
  };
  var REQUEST_STATUS = {
    inactive: 'INACTIVE',
    pending: 'PENDING',
    error: 'ERROR'
  };
  var defaultOptions = {
    triggerQuery: true,
    triggerSuggestionsQuery: false,
    stateChanges: true
  };
  var defaultOption = {
    stateChanges: true
  };

  var Searchbase =
  /*#__PURE__*/
  function () {
    // es index name
    // es url
    // use rs v3 api
    // get query suggestions from `.suggestions` index
    // auth credentials if any
    // to enable the recording of analytics
    // input value i.e query term
    // custom headers object
    // suggestions
    // query suggestions
    // composite aggregations
    // suggestions query error
    // results
    // results query error
    // state changes subject
    // request status
    // suggestions request status
    // following are the es query options

    /* ------------- change events -------------------------------- */
    // called when value changes
    // called when results change
    // called when suggestions change
    // called when query suggestions change
    // called when composite aggregations change
    // called when there is an error while fetching results
    // called when there is an error while fetching suggestions
    // called when request status changes
    // called when suggestions request status changes
    // called when query changes
    // called when suggestions query changes
    // called when mic status changes

    /* ---- callbacks to create the side effects while querying ----- */

    /* ------ Private properties only for the internal use ----------- */
    // counterpart of the query
    // counterpart of the suggestions query
    // mic status
    // mic instance
    // analytics instance
    // query search ID
    function Searchbase(_ref) {
      var _this = this;

      var index$1 = _ref.index,
          url = _ref.url,
          enableAppbase = _ref.enableAppbase,
          enableQuerySuggestions = _ref.enableQuerySuggestions,
          credentials = _ref.credentials,
          appbaseConfig = _ref.appbaseConfig,
          headers = _ref.headers,
          value = _ref.value,
          _suggestions = _ref.suggestions,
          querySuggestions = _ref.querySuggestions,
          _results = _ref.results,
          fuzziness = _ref.fuzziness,
          searchOperators = _ref.searchOperators,
          queryFormat = _ref.queryFormat,
          size = _ref.size,
          from = _ref.from,
          dataField = _ref.dataField,
          aggregationField = _ref.aggregationField,
          includeFields = _ref.includeFields,
          excludeFields = _ref.excludeFields,
          transformQuery = _ref.transformQuery,
          transformSuggestionsQuery = _ref.transformSuggestionsQuery,
          transformRequest = _ref.transformRequest,
          transformResponse = _ref.transformResponse,
          beforeValueChange = _ref.beforeValueChange,
          sortBy = _ref.sortBy,
          nestedField = _ref.nestedField,
          sortOptions = _ref.sortOptions,
          sortByField = _ref.sortByField,
          highlight = _ref.highlight,
          highlightField = _ref.highlightField;

      _defineProperty(this, "index", void 0);

      _defineProperty(this, "url", void 0);

      _defineProperty(this, "enableAppbase", void 0);

      _defineProperty(this, "enableQuerySuggestions", void 0);

      _defineProperty(this, "credentials", void 0);

      _defineProperty(this, "appbaseConfig", void 0);

      _defineProperty(this, "value", void 0);

      _defineProperty(this, "headers", void 0);

      _defineProperty(this, "suggestions", void 0);

      _defineProperty(this, "querySuggestions", void 0);

      _defineProperty(this, "aggregationData", void 0);

      _defineProperty(this, "suggestionsError", void 0);

      _defineProperty(this, "results", void 0);

      _defineProperty(this, "error", void 0);

      _defineProperty(this, "stateChanges", void 0);

      _defineProperty(this, "requestStatus", void 0);

      _defineProperty(this, "suggestionsRequestStatus", void 0);

      _defineProperty(this, "nestedField", void 0);

      _defineProperty(this, "queryFormat", void 0);

      _defineProperty(this, "searchOperators", void 0);

      _defineProperty(this, "size", void 0);

      _defineProperty(this, "from", void 0);

      _defineProperty(this, "fuzziness", void 0);

      _defineProperty(this, "sortBy", void 0);

      _defineProperty(this, "sortByField", void 0);

      _defineProperty(this, "dataField", void 0);

      _defineProperty(this, "aggregationField", void 0);

      _defineProperty(this, "includeFields", void 0);

      _defineProperty(this, "excludeFields", void 0);

      _defineProperty(this, "sortOptions", void 0);

      _defineProperty(this, "highlight", void 0);

      _defineProperty(this, "highlightField", void 0);

      _defineProperty(this, "onValueChange", void 0);

      _defineProperty(this, "onResults", void 0);

      _defineProperty(this, "onSuggestions", void 0);

      _defineProperty(this, "onQuerySuggestions", void 0);

      _defineProperty(this, "onAggregationData", void 0);

      _defineProperty(this, "onError", void 0);

      _defineProperty(this, "onSuggestionsError", void 0);

      _defineProperty(this, "onRequestStatusChange", void 0);

      _defineProperty(this, "onSuggestionsRequestStatusChange", void 0);

      _defineProperty(this, "onQueryChange", void 0);

      _defineProperty(this, "onSuggestionsQueryChange", void 0);

      _defineProperty(this, "onMicStatusChange", void 0);

      _defineProperty(this, "transformQuery", void 0);

      _defineProperty(this, "transformSuggestionsQuery", void 0);

      _defineProperty(this, "transformRequest", void 0);

      _defineProperty(this, "transformResponse", void 0);

      _defineProperty(this, "beforeValueChange", void 0);

      _defineProperty(this, "_query", void 0);

      _defineProperty(this, "_suggestionsQuery", void 0);

      _defineProperty(this, "_queryOptions", void 0);

      _defineProperty(this, "_micStatus", void 0);

      _defineProperty(this, "_micInstance", void 0);

      _defineProperty(this, "_analyticsInstance", void 0);

      _defineProperty(this, "_queryId", void 0);

      _defineProperty(this, "onMicClick", function (micOptions, options) {
        if (micOptions === void 0) {
          micOptions = {};
        }

        if (options === void 0) {
          options = defaultOptions;
        }

        var prevStatus = _this._micStatus;

        if (typeof window !== 'undefined') {
          window.SpeechRecognition = window.webkitSpeechRecognition || window.SpeechRecognition || null;
        }

        if (window && window.SpeechRecognition && prevStatus !== MIC_STATUS.denied) {
          if (prevStatus === MIC_STATUS.active) {
            _this._setMicStatus(MIC_STATUS.inactive, options);
          }

          var _window = window,
              SpeechRecognition = _window.SpeechRecognition;

          if (_this._micInstance) {
            _this._stopMic();

            return;
          }

          _this._micInstance = new SpeechRecognition();
          _this._micInstance.continuous = true;
          _this._micInstance.interimResults = true;
          Object.assign(_this._micInstance, micOptions);

          _this._micInstance.start();

          _this._micInstance.onstart = function () {
            _this._setMicStatus(MIC_STATUS.active, options);
          };

          _this._micInstance.onresult = function (_ref2) {
            var results = _ref2.results;

            if (results && results[0] && results[0].isFinal) {
              _this._stopMic();
            }

            _this._handleVoiceResults({
              results: results
            }, options);
          };

          _this._micInstance.onerror = function (e) {
            if (e.error === 'no-speech' || e.error === 'audio-capture') {
              _this._setMicStatus(MIC_STATUS.inactive, options);
            } else if (e.error === 'not-allowed') {
              _this._setMicStatus(MIC_STATUS.denied, options);
            }

            console.error(e);
          };
        }
      });

      _defineProperty(this, "recordClick", function (objects, isSuggestionClick) {
        if (isSuggestionClick === void 0) {
          isSuggestionClick = false;
        }

        if (_this._analyticsInstance && _this._queryId) {
          _this._analyticsInstance.click({
            queryID: _this._queryId,
            objects: objects,
            isSuggestionClick: isSuggestionClick
          });
        }
      });

      _defineProperty(this, "recordConversions", function (objects) {
        if (_this._analyticsInstance && _this._queryId) {
          _this._analyticsInstance.conversion({
            queryID: _this._queryId,
            objects: objects
          });
        }
      });

      _defineProperty(this, "_handleVoiceResults", function (_ref3, options) {
        var results = _ref3.results;

        if (options === void 0) {
          options = defaultOptions;
        }

        if (results && results[0] && results[0].isFinal && results[0][0] && results[0][0].transcript && results[0][0].transcript.trim()) {
          _this.setValue(results[0][0].transcript.trim(), options);
        }
      });

      _defineProperty(this, "_stopMic", function () {
        if (_this._micInstance) {
          _this._micInstance.stop();

          _this._micInstance = null;

          _this._setMicStatus(MIC_STATUS.inactive);
        }
      });

      _defineProperty(this, "_setMicStatus", function (status, options) {
        if (options === void 0) {
          options = defaultOptions;
        }

        var prevStatus = _this._micStatus;
        _this._micStatus = status;

        _this._applyOptions(options, 'micStatus', prevStatus, _this._micStatus);
      });

      _defineProperty(this, "_parseSuggestions", function (suggestions, sourceSuggestions) {
        var fields = _this.getDataFields();

        if (fields.length === 0 && sourceSuggestions && Array.isArray(sourceSuggestions) && sourceSuggestions.length > 0 && sourceSuggestions[0] && sourceSuggestions[0]._source) {
          // Extract fields from _source
          fields = Object.keys(sourceSuggestions[0]._source);
        }

        return getSuggestions(fields, suggestions, _this.value).slice(0, _this.size);
      });

      _defineProperty(this, "_parseQuerySuggestions", function (suggestions) {
        var fields = ['key', 'key.autosuggest', 'key.search'];
        return getSuggestions(fields, suggestions, _this.value);
      });

      if (!index$1) {
        throw new Error('Please provide a valid index.');
      }

      if (!url) {
        throw new Error('Please provide a valid url.');
      }

      if (!(enableAppbase || dataField)) {
        throw new Error('Please provide a valid data field.');
      }

      this.index = index$1;
      this.url = url;
      this.enableAppbase = enableAppbase || false;
      this.enableQuerySuggestions = enableQuerySuggestions || false;
      this.appbaseConfig = appbaseConfig;
      this._analyticsInstance = index.init({
        index: index$1,
        url: url,
        credentials: credentials
      });
      this.dataField = dataField;
      this.aggregationField = aggregationField;
      this.credentials = credentials || '';
      this.nestedField = nestedField;
      this.queryFormat = queryFormat || 'or';
      this.fuzziness = fuzziness || 0;
      this.searchOperators = searchOperators || false;
      this.size = Number(size) || 10;
      this.from = Number(from) || 0;
      this.sortBy = sortBy;
      this.includeFields = includeFields || ['*'];
      this.excludeFields = excludeFields || [];
      this.sortOptions = sortOptions || null;
      this.sortByField = sortByField;
      this.highlight = highlight;
      this.highlightField = highlightField;
      this.requestStatus = REQUEST_STATUS.inactive;
      this.suggestionsRequestStatus = REQUEST_STATUS.inactive;
      this.transformRequest = transformRequest || null;
      this.transformResponse = transformResponse || null;
      this.transformQuery = transformQuery || null;
      this.transformSuggestionsQuery = transformSuggestionsQuery || null;
      this.beforeValueChange = beforeValueChange || null; // Initialize the state changes observable

      this.stateChanges = new Observable(); // Initialize the results

      this.suggestions = new Results(_suggestions); // Add suggestions parser

      this.suggestions.parseResults = this._parseSuggestions; // Initialize query suggestions

      this.querySuggestions = new Results(querySuggestions); // Add suggestions parser

      this.querySuggestions.parseResults = this._parseQuerySuggestions;
      this.results = new Results(_results); // composite aggs instance

      this.aggregationData = new CompositeAggregationResults(); // Initialize headers

      this.headers = {
        Accept: 'application/json',
        'Content-Type': 'application/json'
      };

      if (this.credentials) {
        this.headers = _extends({}, this.headers, {
          Authorization: "Basic " + btoa(this.credentials)
        });
      }

      if (headers) {
        this.setHeaders(headers, {
          stateChanges: false
        });
      }

      if (value) {
        this.setValue(value, {
          stateChanges: true
        });
      } else {
        this.value = '';
      }
    } // getters


    var _proto = Searchbase.prototype;

    // Method to subscribe the state changes
    _proto.subscribeToStateChanges = function subscribeToStateChanges(fn, propertiesToSubscribe) {
      this.stateChanges.subscribe(fn, propertiesToSubscribe);
    } // Method to unsubscribe the state changes
    ;

    _proto.unsubscribeToStateChanges = function unsubscribeToStateChanges(fn) {
      this.stateChanges.unsubscribe(fn);
    } // Method to set the custom headers
    ;

    _proto.setHeaders = function setHeaders(headers, options) {
      if (options === void 0) {
        options = defaultOptions;
      }

      var prev = this.headers;
      this.headers = _extends({}, this.headers, {}, headers);

      this._applyOptions(options, 'headers', prev, this.headers);
    } // Method to set the size option
    ;

    _proto.setSize = function setSize(size, options) {
      if (options === void 0) {
        options = defaultOptions;
      }

      var prev = this.size;
      this.size = size;

      this._applyOptions(options, 'size', prev, this.size);
    } // Method to set the from option
    ;

    _proto.setFrom = function setFrom(from, options) {
      if (options === void 0) {
        options = defaultOptions;
      }

      var prev = this.from;
      this.from = from;

      this._applyOptions(options, 'from', prev, this.from);
    } // Method to set the fuzziness option
    ;

    _proto.setFuzziness = function setFuzziness(fuzziness, options) {
      if (options === void 0) {
        options = defaultOptions;
      }

      var prev = this.fuzziness;
      this.fuzziness = fuzziness;

      this._applyOptions(options, 'fuzziness', prev, this.fuzziness);
    } // Method to set the includeFields option
    ;

    _proto.setIncludeFields = function setIncludeFields(includeFields, options) {
      if (options === void 0) {
        options = defaultOptions;
      }

      var prev = this.includeFields;
      this.includeFields = includeFields;

      this._applyOptions(options, 'includeFields', prev, includeFields);
    } // Method to set the excludeFields option
    ;

    _proto.setExcludeFields = function setExcludeFields(excludeFields, options) {
      if (options === void 0) {
        options = defaultOptions;
      }

      var prev = this.excludeFields;
      this.excludeFields = excludeFields;

      this._applyOptions(options, 'excludeFields', prev, excludeFields);
    } // Method to set the sortBy option
    ;

    _proto.setSortBy = function setSortBy(sortBy, options) {
      if (options === void 0) {
        options = defaultOptions;
      }

      var prev = this.sortBy;
      this.sortBy = sortBy;

      this._applyOptions(options, 'sortBy', prev, sortBy);
    } // Method to set the sortByField option
    ;

    _proto.setSortByField = function setSortByField(sortByField, options) {
      if (options === void 0) {
        options = defaultOptions;
      }

      var prev = this.sortByField;
      this.sortByField = sortByField;

      this._applyOptions(options, 'sortByField', prev, sortByField);
    } // Method to set the nestedField option
    ;

    _proto.setNestedField = function setNestedField(nestedField, options) {
      if (options === void 0) {
        options = defaultOptions;
      }

      var prev = this.nestedField;
      this.nestedField = nestedField;

      this._applyOptions(options, 'nestedField', prev, nestedField);
    } // Method to set the dataField option
    ;

    _proto.setDataField = function setDataField(dataField, options) {
      if (options === void 0) {
        options = defaultOptions;
      }

      var prev = this.dataField;
      this.dataField = dataField;

      this._applyOptions(options, 'dataField', prev, dataField);
    } // Method to set the custom results
    ;

    _proto.setResults = function setResults(results, options) {
      if (options === void 0) {
        options = defaultOption;
      }

      if (results) {
        var _prev = this.results;
        this.results = new Results(results);

        this._applyOptions({
          stateChanges: options.stateChanges
        }, 'results', _prev, this.results);
      }
    } // Method to set the custom suggestions
    ;

    _proto.setSuggestions = function setSuggestions(suggestions, options) {
      if (options === void 0) {
        options = defaultOption;
      }

      if (suggestions) {
        var _prev2 = this.suggestions;
        this.suggestions = new Results(suggestions);
        this.suggestions.parseResults = this._parseSuggestions;

        this._applyOptions({
          stateChanges: options.stateChanges
        }, 'suggestions', _prev2, this.suggestions);
      }
    } // Method to set the value
    ;

    _proto.setValue = function setValue(value, options) {
      var _this2 = this;

      if (options === void 0) {
        options = defaultOptions;
      }

      var performUpdate = function performUpdate() {
        var prev = _this2.value;
        _this2.value = value;

        _this2._applyOptions(options, 'value', prev, _this2.value);
      };

      if (this.beforeValueChange) {
        this.beforeValueChange(value).then(performUpdate)["catch"](function (e) {
          console.warn('beforeValueChange rejected the promise with ', e);
        });
      } else {
        performUpdate();
      }
    } // mic event
    ;

    // Method to execute the query
    _proto.triggerQuery = function triggerQuery(options) {
      var _this3 = this;

      if (options === void 0) {
        options = defaultOption;
      }

      var handleError = function handleError(err) {
        _this3._setError(err, {
          stateChanges: options.stateChanges
        });

        console.error(err);
        return Promise.reject(err);
      };

      try {
        this._updateQuery();

        this._setRequestStatus(REQUEST_STATUS.pending);

        var transformQuery = this.transformQuery ? this.transformQuery(this.query) : new Promise(function (res) {
          return res(_this3.query);
        });
        return transformQuery.then(function (finalQuery) {
          _this3._fetchRequest(finalQuery).then(function (results) {
            _this3._setRequestStatus(REQUEST_STATUS.inactive);

            var prev = _this3.results;
            var rawResults = results;
            if (_this3.enableAppbase) rawResults = results.SearchResult;

            _this3.results.setRaw(rawResults);

            _this3._applyOptions({
              stateChanges: options.stateChanges
            }, 'results', prev, _this3.results);

            return Promise.resolve(rawResults);
          })["catch"](handleError);
        })["catch"](handleError);
      } catch (err) {
        return handleError(err);
      }
    } // Method to execute the suggestions query
    ;

    _proto.triggerSuggestionsQuery = function triggerSuggestionsQuery(options) {
      var _this4 = this;

      if (options === void 0) {
        options = defaultOption;
      }

      var handleError = function handleError(err) {
        _this4._setSuggestionsError(err, {
          stateChanges: options.stateChanges
        });

        console.error(err);
        return Promise.reject(err);
      };

      try {
        this._updateSuggestionsQuery();

        this._setSuggestionsRequestStatus(REQUEST_STATUS.pending);

        var transformSuggestionsQuery = this.transformSuggestionsQuery ? this.transformSuggestionsQuery(this.suggestionsQuery) : new Promise(function (res) {
          return res(_this4.suggestionsQuery);
        });
        return transformSuggestionsQuery.then(function (finalQuery) {
          _this4._fetchRequest(finalQuery).then(function (suggestions) {
            var rawSuggestions = suggestions;
            if (_this4.enableAppbase) rawSuggestions = suggestions.DataSearch;

            if (_this4.enableAppbase && _this4.enableQuerySuggestions) {
              _this4._fetchRequest(_this4.getSuggestionsQuery(), true).then(function (rawQuerySuggestions) {
                _this4._setSuggestionsRequestStatus(REQUEST_STATUS.inactive);

                _this4._handleQuerySuggestionsResponse(rawQuerySuggestions, options);
              })["catch"](handleError);
            } else _this4._setSuggestionsRequestStatus(REQUEST_STATUS.inactive);

            if (rawSuggestions.aggregations) {
              _this4._handleCompositeAggsResponse(_this4.aggregationField, rawSuggestions.aggregations, options);
            }

            var prev = _this4.suggestions;

            _this4.suggestions.setRaw(rawSuggestions);

            _this4._applyOptions({
              stateChanges: options.stateChanges
            }, 'suggestions', prev, _this4.suggestions);

            return Promise.resolve(rawSuggestions);
          })["catch"](handleError);
        })["catch"](handleError);
      } catch (err) {
        return handleError(err);
      }
    };

    _proto.getSuggestionsQuery = function getSuggestionsQuery() {
      return {
        query: [{
          id: 'DataSearch__suggestions',
          dataField: ['key', 'key.autosuggest', 'key.search'],
          searchOperators: this.searchOperators,
          size: 5,
          value: this.value,
          defaultQuery: {
            sort: [{
              count: {
                order: 'desc'
              }
            }]
          }
        }]
      };
    }
    /*
     methods to record analytics
    */
    // use this methods to record a search click event
    ;

    _proto._handleCompositeAggsResponse = function _handleCompositeAggsResponse(aggregationField, aggsResponse, options) {
      if (options === void 0) {
        options = defaultOptions;
      }

      var prev = this.aggregationData;
      this.aggregationData.setRaw(aggsResponse[aggregationField]);
      this.aggregationData.setData(aggregationField, aggsResponse[aggregationField].buckets);

      this._applyOptions({
        stateChanges: options.stateChanges
      }, 'aggregations', prev, this.aggregationData);
    };

    _proto._handleTransformResponse = function _handleTransformResponse(res) {
      if (this.transformResponse && typeof this.transformResponse === 'function') {
        return this.transformResponse(res);
      }

      return new Promise(function (resolve) {
        return resolve(res);
      });
    };

    _proto._handleTransformRequest = function _handleTransformRequest(requestOptions) {
      if (this.transformRequest && typeof this.transformRequest === 'function') {
        return this.transformRequest(requestOptions);
      }

      return new Promise(function (resolve) {
        return resolve(requestOptions);
      });
    };

    _proto._handleQuerySuggestionsResponse = function _handleQuerySuggestionsResponse(rawQuerySuggestions, options) {
      var prev = this.querySuggestions;
      var querySuggestions = rawQuerySuggestions && rawQuerySuggestions.DataSearch__suggestions;
      this.querySuggestions.setRaw(querySuggestions);

      this._applyOptions({
        stateChanges: options.stateChanges
      }, 'querySuggestions', prev, this.querySuggestions);
    };

    _proto._fetchRequest = function _fetchRequest(requestBody, isQuerySuggestionsAPI) {
      var _this5 = this;

      if (isQuerySuggestionsAPI === void 0) {
        isQuerySuggestionsAPI = false;
      }

      var requestOptions = {
        method: 'POST',
        body: JSON.stringify(requestBody),
        headers: _extends({}, this.headers)
      };
      return new Promise(function (resolve, reject) {
        _this5._handleTransformRequest(requestOptions).then(function (finalRequestOptions) {
          // set timestamp in request
          var timestamp = Date.now();
          var suffix = '_search';
          if (_this5.enableAppbase) suffix = '_reactivesearch.v3';
          var index = isQuerySuggestionsAPI ? '.suggestions' : _this5.index;
          return browserPonyfill(_this5.url + "/" + index + "/" + suffix, finalRequestOptions).then(function (res) {
            var responseHeaders = res.headers; // set search id

            if (res.headers) {
              _this5._queryId = res.headers.get('X-Search-Id') || null;
            }

            if (res.status >= 500) {
              return reject(res);
            }

            if (res.status >= 400) {
              return reject(res);
            }

            return res.json().then(function (data) {
              _this5._handleTransformResponse(data).then(function (transformedData) {
                if (transformedData && Object.prototype.hasOwnProperty.call(transformedData, 'error')) {
                  reject(transformedData);
                }

                var response = _extends({}, transformedData, {
                  _timestamp: timestamp,
                  _headers: responseHeaders
                });

                return resolve(response);
              })["catch"](function (e) {
                console.warn('transformResponse rejected the promise with ', e);
                return reject(e);
              });
            });
          })["catch"](function (e) {
            return reject(e);
          });
        })["catch"](function (e) {
          console.warn('transformRequest rejected the promise with ', e);
          return reject(e);
        });
      });
    };

    _proto._setSuggestionsError = function _setSuggestionsError(suggestionsError, options) {
      if (options === void 0) {
        options = defaultOptions;
      }

      this._setSuggestionsRequestStatus(REQUEST_STATUS.error);

      var prev = this.suggestionsError;
      this.suggestionsError = suggestionsError;

      this._applyOptions(options, 'suggestionsError', prev, this.suggestionsError);
    };

    _proto._setError = function _setError(error, options) {
      if (options === void 0) {
        options = defaultOptions;
      }

      this._setRequestStatus(REQUEST_STATUS.error);

      var prev = this.error;
      this.error = error;

      this._applyOptions(options, 'error', prev, this.error);
    };

    _proto._setRequestStatus = function _setRequestStatus(requestStatus) {
      var prev = this.requestStatus;
      this.requestStatus = requestStatus;

      this._applyOptions({
        stateChanges: true
      }, 'requestStatus', prev, this.requestStatus);
    };

    _proto._setSuggestionsRequestStatus = function _setSuggestionsRequestStatus(suggestionsRequestStatus) {
      var prev = this.suggestionsRequestStatus;
      this.suggestionsRequestStatus = suggestionsRequestStatus;

      this._applyOptions({
        stateChanges: true
      }, 'suggestionsRequestStatus', prev, this.suggestionsRequestStatus);
    } // Method to set the default query value
    ;

    _proto._updateQuery = function _updateQuery(query, queryOptions) {
      var prevQuery;

      if (this.enableAppbase) {
        prevQuery = _extends({}, this._query);
        this._query = {
          query: [_extends({}, this.getAppbaseSuggestionsQuery(), {
            execute: false
          }), this.getAppbaseResultQuery()],
          settings: this.getAppbaseSettings()
        };
      } else prevQuery = this.getPreviousQuery(query, queryOptions);

      this._applyOptions({
        stateChanges: false
      }, 'query', prevQuery, this._query);
    };

    _proto.getAppbaseSettings = function getAppbaseSettings() {
      var _this$appbaseConfig = this.appbaseConfig,
          recordAnalytics = _this$appbaseConfig.recordAnalytics,
          customEvents = _this$appbaseConfig.customEvents,
          enableQueryRules = _this$appbaseConfig.enableQueryRules,
          userId = _this$appbaseConfig.userId;
      return {
        recordAnalytics: recordAnalytics,
        customEvents: customEvents,
        enableQueryRules: enableQueryRules,
        userId: userId
      };
    };

    _proto.getAppbaseResultQuery = function getAppbaseResultQuery() {
      return {
        id: 'SearchResult',
        dataField: this.getDataFields(),
        from: this.from,
        size: this.size,
        sortBy: this.sortBy,
        includeFields: this.includeFields,
        excludeFields: this.excludeFields,
        react: {
          and: 'DataSearch'
        }
      };
    };

    _proto.getPreviousQuery = function getPreviousQuery(query, queryOptions) {
      // Set default query here
      var finalQueryOptions = Searchbase.generateQueryOptions({
        excludeFields: this.excludeFields,
        includeFields: this.includeFields,
        size: this.size,
        from: this.from,
        sortBy: this.sortBy,
        sortByField: this.sortByField,
        sortOptions: this.sortOptions
      });
      /**
       * First priority goes to the custom query set by user otherwise execute the default query
       * If none of the two exists execute the match_all
       */

      var finalQuery = query || Searchbase.defaultQuery(this.value, {
        dataField: this.dataField,
        searchOperators: this.searchOperators,
        queryFormat: this.queryFormat,
        fuzziness: this.fuzziness,
        nestedField: this.nestedField
      }) || {
        match_all: {}
      };
      var prevQuery = this._query;
      this._query = _extends({
        query: finalQuery
      }, Searchbase.highlightQuery(this.highlight, this.highlightField, this.dataField), {}, finalQueryOptions, {}, queryOptions);
      return prevQuery;
    };

    _proto._updateSuggestionsQuery = function _updateSuggestionsQuery(query, queryOptions) {
      var prevQuery;

      if (this.enableAppbase) {
        prevQuery = _extends({}, this._suggestionsQuery);
        this._suggestionsQuery = {
          query: [this.getAppbaseSuggestionsQuery()],
          settings: this.getAppbaseSettings()
        };
      } else prevQuery = this.getPreviousSuggestionsQuery(query, queryOptions);

      this._applyOptions({
        stateChanges: false
      }, 'suggestionsQuery', prevQuery, this._suggestionsQuery);
    };

    _proto.getAppbaseSuggestionsQuery = function getAppbaseSuggestionsQuery() {
      return {
        id: 'DataSearch',
        dataField: this.getDataFields(),
        value: this.value,
        queryFormat: this.queryFormat,
        nestedField: this.nestedField,
        from: this.from,
        size: this.size,
        sortBy: this.sortBy,
        aggregationField: this.aggregationField,
        includeFields: this.includeFields,
        excludeFields: this.excludeFields,
        fuzziness: this.fuzziness,
        searchOperators: this.searchOperators,
        highlight: this.highlight,
        highlightField: this.highlightField
      };
    };

    _proto.getPreviousSuggestionsQuery = function getPreviousSuggestionsQuery(query, queryOptions) {
      // Set default suggestions query here
      var finalQueryOptions = Searchbase.generateQueryOptions({
        aggregationField: this.aggregationField,
        size: this.size
      });
      /**
       * First priority goes to the custom query set by user otherwise execute the default query
       * If none of the two exists execute the match_all
       */

      var finalQuery = query || Searchbase.defaultQuery(this.value, {
        dataField: this.dataField,
        searchOperators: this.searchOperators,
        queryFormat: this.queryFormat,
        fuzziness: this.fuzziness,
        nestedField: this.nestedField
      }) || {
        match_all: {}
      };

      var prevQuery = _extends({}, this._suggestionsQuery);

      this._suggestionsQuery = _extends({
        query: finalQuery
      }, Searchbase.highlightQuery(this.highlight, this.highlightField, this.dataField), {}, finalQueryOptions, {}, queryOptions);
      return prevQuery;
    };

    _proto.getDataFields = function getDataFields() {
      var fields = [];

      if (this.dataField === 'string') {
        fields = [this.dataField];
      } else if (Array.isArray(this.dataField)) {
        this.dataField.forEach(function (dataField) {
          if (typeof dataField === 'object') {
            fields.push(dataField.field);
          } else {
            fields.push(dataField);
          }
        });
      }

      return fields;
    } // Method to apply the changed based on set options
    ;

    _proto._applyOptions = function _applyOptions(options, key, prevValue, nextValue) {
      // Trigger mic events
      if (key === 'micStatus' && this.onMicStatusChange) {
        this.onMicStatusChange(nextValue, prevValue);
      } // Trigger events


      if (key === 'query' && this.onQueryChange) {
        this.onQueryChange(nextValue, prevValue);
      }

      if (key === 'suggestionsQuery' && this.onSuggestionsQueryChange) {
        this.onSuggestionsQueryChange(nextValue, prevValue);
      }

      if (key === 'value' && this.onValueChange) {
        this.onValueChange(nextValue, prevValue);
      }

      if (key === 'error' && this.onError) {
        this.onError(nextValue);
      }

      if (key === 'suggestionsError' && this.onSuggestionsError) {
        this.onSuggestionsError(nextValue);
      }

      if (key === 'results' && this.onResults) {
        this.onResults(nextValue, prevValue);
      }

      if (key === 'suggestions' && this.onSuggestions) {
        this.onSuggestions(nextValue, prevValue);
      }

      if (key === 'querySuggestions' && this.onQuerySuggestions) {
        this.onQuerySuggestions(nextValue, prevValue);
      }

      if (key === 'aggregations' && this.onAggregationData) {
        this.onAggregationData(nextValue, prevValue);
      }

      if (key === 'requestStatus' && this.onRequestStatusChange) {
        this.onRequestStatusChange(nextValue, prevValue);
      }

      if (key === 'suggestionsRequestStatus' && this.onSuggestionsRequestStatusChange) {
        this.onSuggestionsRequestStatusChange(nextValue, prevValue);
      }

      if (options.triggerQuery) {
        this.triggerQuery();
      }

      if (options.triggerSuggestionsQuery) {
        this.triggerSuggestionsQuery();
      }

      if (options.stateChanges !== false) {
        var _this$stateChanges$ne;

        this.stateChanges.next((_this$stateChanges$ne = {}, _this$stateChanges$ne[key] = {
          prev: prevValue,
          next: nextValue
        }, _this$stateChanges$ne), key);
      }
    };

    _createClass(Searchbase, [{
      key: "micStatus",
      get: function get() {
        return this._micStatus;
      }
    }, {
      key: "micInstance",
      get: function get() {
        return this._micInstance;
      }
    }, {
      key: "micActive",
      get: function get() {
        return this._micStatus === MIC_STATUS.active;
      }
    }, {
      key: "micInactive",
      get: function get() {
        return this._micStatus === MIC_STATUS.inactive;
      }
    }, {
      key: "micDenied",
      get: function get() {
        return this._micStatus === MIC_STATUS.denied;
      }
    }, {
      key: "query",
      get: function get() {
        return this._query;
      }
    }, {
      key: "suggestionsQuery",
      get: function get() {
        return this._suggestionsQuery;
      }
    }, {
      key: "requestPending",
      get: function get() {
        return this.requestStatus === REQUEST_STATUS.pending;
      }
    }, {
      key: "suggestionsRequestPending",
      get: function get() {
        return this.suggestionsRequestStatus === REQUEST_STATUS.pending;
      }
    }]);

    return Searchbase;
  }();
  /* ------------------ Static methods ------------------------------ */
  // function to generate the default query DSL


  _defineProperty(Searchbase, "defaultQuery", void 0);

  _defineProperty(Searchbase, "shouldQuery", void 0);

  _defineProperty(Searchbase, "highlightQuery", void 0);

  _defineProperty(Searchbase, "compositeAggsQuery", void 0);

  _defineProperty(Searchbase, "generateQueryOptions", void 0);

  Searchbase.defaultQuery = function (value, options) {
    var finalQuery = null;
    var fields;

    if (value) {
      if (Array.isArray(options.dataField)) {
        fields = options.dataField;
      } else {
        fields = [options.dataField];
      }

      if (options.searchOperators) {
        finalQuery = {
          simple_query_string: Searchbase.shouldQuery(value, fields, options)
        };
      } else {
        finalQuery = {
          bool: {
            should: Searchbase.shouldQuery(value, fields, options),
            minimum_should_match: '1'
          }
        };
      }
    }

    if (value === '') {
      finalQuery = null;
    }

    if (finalQuery && options.nestedField) {
      finalQuery = {
        nested: {
          path: options.nestedField,
          query: finalQuery
        }
      };
    }

    return finalQuery;
  }; // helper function of default query


  Searchbase.shouldQuery = function (value, dataFields, options) {
    if (options === void 0) {
      options = {
        searchOperators: false,
        queryFormat: 'or',
        fuzziness: 0
      };
    }

    var fields = dataFields.map(function (dataField) {
      if (typeof dataField === 'object') {
        return "" + dataField.field + (dataField.weight ? "^" + dataField.weight : '');
      }

      return dataField;
    });

    if (options.searchOperators) {
      return {
        query: value,
        fields: fields,
        default_operator: options.queryFormat
      };
    }

    if (options.queryFormat === 'and') {
      return [{
        multi_match: {
          query: value,
          fields: fields,
          type: 'cross_fields',
          operator: 'and'
        }
      }, {
        multi_match: {
          query: value,
          fields: fields,
          type: 'phrase',
          operator: 'and'
        }
      }];
    }

    return [{
      multi_match: {
        query: value,
        fields: fields,
        type: 'best_fields',
        operator: 'or',
        fuzziness: options.fuzziness
      }
    }, {
      multi_match: {
        query: value,
        fields: fields,
        type: 'phrase',
        operator: 'or'
      }
    }];
  }; // helper function to generate highlight query


  Searchbase.highlightQuery = function (highlight, highlightFields, dataFields) {
    if (!highlight) return null;
    var fields = {};
    var highlightField = highlightFields || dataFields;
    var flatHighlightedFields = typeof highlightFields === 'string' ? [highlightFields] : highlightFields;

    if (typeof highlightField === 'string') {
      fields[highlightField] = {};
    } else if (Array.isArray(highlightField)) {
      highlightField.forEach(function (item) {
        if (typeof item === 'object') fields[item.field] = {};else fields[item] = {};
      });
    }

    return {
      highlight: _extends({
        pre_tags: ['<mark>'],
        post_tags: ['</mark>'],
        fields: fields
      }, flatHighlightedFields && {
        require_field_match: false
      })
    };
  }; // helper function to generate composite aggregations query


  Searchbase.compositeAggsQuery = function (aggregationField, size) {
    var _ref4, _aggs, _aggs2;

    return {
      aggs: (_aggs2 = {}, _aggs2[aggregationField] = {
        composite: {
          sources: [(_ref4 = {}, _ref4[aggregationField] = {
            terms: {
              field: aggregationField
            }
          }, _ref4)],
          size: size
        },
        aggs: (_aggs = {}, _aggs[aggregationField] = {
          top_hits: {
            size: 1
          }
        }, _aggs)
      }, _aggs2)
    };
  }; // function to generate the query DSL options


  Searchbase.generateQueryOptions = function (options) {
    var finalOptions = {};

    if (options.size !== undefined) {
      finalOptions.size = options.size;
    }

    if (options.from !== undefined) {
      finalOptions.from = options.from;
    }

    if (options.includeFields || options.excludeFields) {
      var source = {};

      if (options.includeFields) {
        source.includes = options.includeFields;
      }

      if (options.excludeFields) {
        source.excludes = options.excludeFields;
      }

      finalOptions._source = source;
    }

    if (options.sortOptions) {
      var _ref5;

      finalOptions.sort = [(_ref5 = {}, _ref5[options.sortOptions[0].dataField] = {
        order: options.sortOptions[0].sortBy
      }, _ref5)];
    } else if (options.sortBy && options.sortByField) {
      var _ref6;

      finalOptions.sort = [(_ref6 = {}, _ref6[options.sortByField] = {
        order: options.sortBy
      }, _ref6)];
    }

    if (options.aggregationField) {
      finalOptions.aggs = Searchbase.compositeAggsQuery(options.aggregationField, options.size || 0).aggs;
    }

    return finalOptions;
  };

  return Searchbase;

})));
//# sourceMappingURL=searchbase.umd.js.map
